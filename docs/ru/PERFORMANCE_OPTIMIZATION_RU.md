# Руководство по оптимизации производительности API

## Обзор

Это руководство документирует оптимизации производительности, реализованные в Phoebe CMS, и предоставляет рекомендации для сценариев с высоким трафиком.

## Реализованные оптимизации

### 1. Предотвращение проблемы N+1

**Проблема**: Загрузка списка новостей вызывала отдельные запросы для каждой связи `author` и `terms`.

**Решение**: Добавлены аннотации `@EntityGraph` к методам NewsRepository:

```java
@EntityGraph(attributePaths = {"author", "terms"})
Page<News> findByPublished(boolean published, Pageable pageable);
```

**Эффект**: Сокращает количество запросов с `1 + N + N` до `1` для операций получения списков.

### 2. SQL логирование для диагностики

**Конфигурация** (`application-local.yml`):
```yaml
spring:
  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true

logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
```

**Использование**: Мониторинг вывода в консоли для выявления:
- Паттернов N+1 запросов
- Отсутствующих индексов
- Неэффективных JOIN операций

### 3. Пакетные операции

**Конфигурация**:
```yaml
hibernate:
  jdbc:
    batch_size: 20
  order_inserts: true
  order_updates: true
```

**Эффект**: Группирует множественные INSERT/UPDATE операции в пакеты, сокращая обращения к базе данных.

### 4. Индексы базы данных

**Существующие индексы** (сущность News):
- `idx_news_published` - для фильтрации по статусу публикации
- `idx_news_publication_date` - для сортировки по дате
- `idx_news_published_pubdate` - составной индекс для частых запросов
- `idx_news_author` - для фильтрации по автору

### 5. Стратегия ленивой загрузки

**Реализация**:
- Поля `body` и `teaser` используют `@Basic(fetch = FetchType.LAZY)`
- Все связи (`author`, `terms`) используют `FetchType.LAZY`
- EntityGraph явно загружает необходимые ассоциации

**Преимущество**: Уменьшает размер начального запроса, загружает данные только при необходимости.

## Рекомендации по тестированию производительности

### 1. Нагрузочное тестирование

Используйте инструменты типа Apache JMeter или Gatling для симуляции высокого трафика:

```bash
# Пример: 100 одновременных пользователей, 1000 запросов
ab -n 1000 -c 100 http://localhost:8080/api/public/news
```

### 2. Анализ запросов

Включите SQL логирование и проверьте:
- Множественные SELECT запросы для одного типа сущности (N+1)
- Полное сканирование таблиц (отсутствующие индексы)
- Декартовы произведения в JOIN

### 3. Профилирование базы данных

**MySQL**:
```sql
-- Включить лог медленных запросов
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;

-- Анализ производительности запроса
EXPLAIN SELECT * FROM content WHERE published = true;
```

## Чек-лист оптимизации

- [x] EntityGraph для жадной загрузки ассоциаций
- [x] SQL логирование включено в local профиле
- [x] Пакетные операции настроены
- [x] Индексы базы данных на часто запрашиваемых колонках
- [x] Ленивая загрузка для больших текстовых полей
- [ ] Настройка пула соединений для продакшена
- [ ] Redis кэширование для часто запрашиваемых данных
- [ ] CDN для статического контента
- [ ] Кэширование результатов запросов к БД

## Будущие оптимизации

### 1. Слой кэширования

Реализовать Redis кэширование для:
- Списков опубликованных новостей
- Данных терминов/категорий
- Токенов аутентификации пользователей

### 2. Реплики для чтения

Для сценариев с высоким трафиком:
- Настроить реплики для SELECT запросов
- Направлять операции записи на основную БД
- Использовать `@Transactional(readOnly = true)` для использования реплик

### 3. Партиционирование базы данных

Для больших объемов данных:
- Партиционировать таблицу `content` по дате публикации
- Архивировать старые новости в отдельные таблицы

### 4. Сжатие ответов API

Включить GZIP сжатие в Spring Boot:
```yaml
server:
  compression:
    enabled: true
    mime-types: application/json,application/xml,text/html,text/xml,text/plain
```

## Мониторинг

### Ключевые метрики для отслеживания

1. **Время ответа**: Среднее время ответа API (цель: <200мс)
2. **Пропускная способность**: Запросов в секунду
3. **Пул соединений БД**: Активные/неактивные соединения
4. **Время выполнения запросов**: Анализ лога медленных запросов
5. **Процент попаданий в кэш**: Если кэширование реализовано

### Инструменты

- **Spring Boot Actuator**: `/actuator/metrics`
- **Prometheus + Grafana**: Метрики временных рядов
- **MySQL Performance Schema**: Анализ запросов
- **New Relic / DataDog**: APM решения

## Лучшие практики

1. **Всегда используйте пагинацию** для списковых эндпоинтов
2. **Ограничивайте размер результата** (макс. 100 элементов на страницу)
3. **Используйте EntityGraph** вместо JOIN FETCH в запросах
4. **Профилируйте перед оптимизацией** - измеряйте реальные узкие места
5. **Тестируйте с объемами данных, близкими к продакшену**

## Ссылки

- [Настройка производительности Hibernate](https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#performance)
- [Лучшие практики Spring Data JPA](https://spring.io/guides/gs/accessing-data-jpa/)
- [Оптимизация запросов MySQL](https://dev.mysql.com/doc/refman/8.0/en/optimization.html)
