# Подходы к локальной разработке

В этом документе описаны два основных подхода к настройке и работе с проектом на локальной машине. Понимание этих подходов поможет вам выбрать наиболее удобный рабочий процесс.

## Содержание
- [Подход 1: Гибридная разработка (Текущая настройка)](#подход-1-гибридная-разработка-текущая-настройка)
  - [Как это работает?](#как-это-работает)
  - [Необходимое ПО](#необходимое-по)
  - [Преимущества и недостатки](#преимущества-и-недостатки)
- [Подход 2: Полностью контейнеризированная разработка](#подход-2-полностью-контейнеризированная-разработка)
  - [Концепция многостадийной сборки (Multi-stage build)](#концепция-многостадийной-сборки-multi-stage-build)
  - [Необходимое ПО](#необходимое-по-1)
  - [Преимущества и недостатки](#преимущества-и-недостатки-1)
- [Практические шаги для перехода на многостадийную сборку](#практические-шаги-для-перехода-на-многостадийную-сборку)
  - [Изменение Dockerfile для бэкенда](#изменение-dockerfile-для-бэкенда)
  - [Изменение `docker-compose.yml`](#изменение-docker-composeyml)
- [Настройка IntelliJ IDEA для работы с Docker](#настройка-intellij-idea-для-работы-с-docker)

---

## Подход 1: Гибридная разработка (Текущая настройка)

Это подход, который используется в проекте по умолчанию. Он сочетает удобство работы в локальной IDE с изоляцией времени выполнения в Docker.

### Как это работает?
1.  Вы пишете код на своем компьютере в IntelliJ IDEA.
2.  Когда вы запускаете команду `make run`, Docker забирает **весь исходный код** вашего бэкенда.
3.  Внутри Docker-контейнера, в котором уже есть полноценный JDK, запускается Gradle. Он компилирует ваш код и запускает приложение.
4.  Ваша локальная IDE (IntelliJ IDEA) использует локально установленный JDK для анализа кода, автодополнения, навигации и, что важно, для **запуска юнит-тестов**, что очень быстро и удобно.

Таким образом, **компиляция и запуск** приложения происходят в Docker, а **анализ кода и юнит-тестирование** — на вашей локальной машине.

### Необходимое ПО
-   **Docker Desktop**: Для запуска контейнеров.
-   **Java (JDK)**: Необходим для корректной работы IntelliJ IDEA (анализ кода, автодополнение) и для локального запуска юнит-тестов.
-   **IntelliJ IDEA**: Ваша среда разработки.

### Преимущества и недостатки

| Преимущества | Недостатки |
|:---|:---|
| ✅ **Быстрые юнит-тесты**: Можно запускать юнит-тесты прямо из IDE одним кликом, без Docker. | ❌ **Требуется локальный JDK**: Необходимо устанавливать и поддерживать Java на своей машине. |
| ✅ **Полная поддержка IDE**: Все функции "умной" среды разработки работают из коробки. | ❌ **Возможны расхождения**: Версия Java в IDE и в Docker-контейнере может отличаться, что теоретически может привести к проблемам. |
| ✅ **Консистентное окружение выполнения**: Финальное приложение всегда работает в одном и том же Docker-окружении. | ❌ **Медленный первый запуск**: При первом запуске `make run` Docker скачивает Gradle и все зависимости, что может занять время. |

---

## Подход 2: Полностью контейнеризированная разработка

Этот подход нацелен на то, чтобы **полностью избавиться от локальных зависимостей**, таких как Java. Единственным инструментом на вашей машине остается Docker.

### Концепция многостадийной сборки (Multi-stage build)
Сборка Docker-образа происходит в два этапа:

1.  **Этап "Сборщик" (Builder Stage)**:
    -   Используется временный Docker-образ с полным набором инструментов: **JDK** и **Gradle**.
    -   В этот образ копируется исходный код.
    -   Внутри него происходит компиляция и создается исполняемый `.jar` файл.

2.  **Этап "Исполнитель" (Final Stage)**:
    -   Создается новый, минималистичный образ, в котором есть только среда для запуска Java — **JRE**.
    -   Из образа "Сборщик" копируется **только один `.jar` файл**.
    -   Весь "мусор" (исходники, JDK, Gradle) остается в прошлом и не попадает в финальный образ.

В результате получается маленький, быстрый и безопасный образ, а на вашей машине не требуется ничего, кроме Docker.

### Необходимое ПО
-   **Docker Desktop**: Единственная необходимая зависимость.
-   **IntelliJ IDEA**: Среда разработки (с плагином для Docker).

### Преимущества и недостатки

| Преимущества | Недостатки |
|:---|:---|
| ✅ **Java не нужна локально**: Ваш компьютер остается "чистым". | ❌ **Настройка IDE сложнее**: Для запуска тестов или отладки из IDE потребуется настроить ее на выполнение команд внутри Docker. |
| ✅ **Максимальная консистентность**: Среда сборки и среда выполнения на 100% идентичны для всех разработчиков и для CI/CD. | ❌ **Медленный цикл разработки?**: Запуск тестов через Docker может быть медленнее, чем локальный запуск из IDE. |
| ✅ **Оптимизированные образы**: Финальные образы получаются маленькими и более безопасными. | ❌ **Требует изучения**: Необходимо понимать, как работает интеграция IDE с Docker. |

---

## Практические шаги для перехода на многостадийную сборку

### Изменение Dockerfile для бэкенда
Вам нужно будет заменить содержимое вашего `Dockerfile.dev` (или создать новый `Dockerfile`) на следующее:

```dockerfile
# --- STAGE 1: BUILD ---
# Use an official Gradle image with a JDK as a builder stage
# Use an alias "builder" for this stage
FROM gradle:8.7-jdk21 AS builder

# Set the working directory
WORKDIR /home/gradle/src

# Copy the entire project context to the build stage
COPY . .

# Run the Gradle build to create the executable jar
# The --no-daemon flag is recommended for CI/CD and containerized environments
RUN gradle :backend:build --no-daemon

# --- STAGE 2: RUN ---
# Use a lightweight JRE image for the final stage
FROM openjdk:21-jre-slim

# Set the working directory in the final container
WORKDIR /app

# Magic happens here:
# Copy ONLY the built jar from the "builder" stage into the final image
COPY --from=builder /home/gradle/src/backend/build/libs/*.jar app.jar

# Expose the port the application runs on
EXPOSE 8080

# The command to run the application
ENTRYPOINT ["java","-jar","/app/app.jar"]
```

### Изменение `docker-compose.yml`
В файле `docker-compose.yml` (или `docker-compose.override.yml`) вам нужно будет изменить секцию `build` для сервиса `phoebe-app`, чтобы она указывала на новый Dockerfile и контекст сборки.

**Пример:**
```yaml
services:
  phoebe-app:
    build:
      context: ../../ # Контекст теперь - корень проекта
      dockerfile: backend/Dockerfile # Путь к вашему новому Dockerfile
    ports:
      - "8080:8080"
    # ... остальные настройки
```
Команда `make run` (которая вызывает `docker compose up --build`) после этих изменений будет автоматически использовать многостадийную сборку.

---

## Настройка IntelliJ IDEA для работы с Docker

При переходе на полностью контейнеризированный подход, вам нужно "научить" IDE работать с Docker.

1.  **Подключите Docker**:
    -   Убедитесь, что в IntelliJ IDEA включен плагин "Docker".
    -   Откройте окно `Services` (`View -> Tool Windows -> Services`).
    -   Нажмите `+` и выберите `Docker Connection`. IDE должна автоматически найти ваш Docker Desktop.

2.  **Запуск проекта из IDE**:
    -   Вместо запуска через терминал, вы можете создать конфигурацию `Docker-compose`.
    -   `Run -> Edit Configurations... -> + -> Docker -> Docker-compose`.
    -   Укажите путь к вашему `docker-compose.yml` файлу.
    -   Теперь вы можете запускать и останавливать весь проект прямо из IDE.

3.  **Запуск тестов (самый сложный момент)**:
    -   **Вариант А (Простой)**: Запускать тесты из терминала, выполняя команду внутри работающего контейнера:
        ```bash
        docker compose exec phoebe-app ./gradlew test
        ```
    -   **Вариант Б (Продвинутый)**: Настроить тестовую конфигурацию в IDE, которая будет делать то же самое. Это требует более глубокой настройки `Run/Debug Configurations`.

Этот документ должен дать вам полное представление о двух подходах и помочь выбрать наилучший путь для вашего проекта.